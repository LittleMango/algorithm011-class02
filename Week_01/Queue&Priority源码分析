> 要看实现了同一个接口的几个类的异同，最快速的方法在于查看他们的源码前面关于类的简述，很多情况下在开头的注释中会提到该类与其它同类的异同，比如当从Queue的角度看，ArrayDeque会比LinkedList更加高效。

1. Queue是接口，PriorityQueue是实现了该接口的一个类，后者拥有前者的所有方法
2. Queue的实现类比较常见有以下几种类型
* 以数组作为容器的ArrayDeque
* 以链表作为容器的LinkedList
* 以堆作为容器的PriorityQueue

下面简单分析一下以上三种数据接口
1. ArrayDeque实现了Deque接口，而Deque继承了Queue接口，并且在其基础上为原有的方法新增一对`xxxFirst`、`xxxLast`操作，实现可以在队头、队位插入、删除元素的目的，由于使用的是数组作为容器(O(1)的随机访问时间，CPU Cache按连续内存块的读取逻辑)，相较于链表，单从Queue的角度来看，它会比LinkedList更加高效。

2. LinkedList和ArrayDeque类似，也是实现了Deque接口，采用双链表的结构作为数据容器，该类持有两个字段，分别是头结点和尾节点，如果只在队头、队位做操作，其时间复杂度也是常量时间复杂度。

3. PriorityQueue采用堆作为存储数据的结构，在Java1.8中，这个堆是平衡二叉堆，用数组作为容器，而且堆中的元素带有权重(优先级)，可以在构造方法中通过传入一个实现了`Comparator`接口的对象来实现优先级比较。由于在入队和出队的时候会进行堆画，因此在入队和出队的时候时间复杂度是O(logn)。

最后，以上三种都是非线程安全的，其对应的线程安全类以上的特性是一样的，更多的分析应该放在线程同步的机制上进行分析，比如：
* 悲观锁，是锁全局对象还是锁分段，锁分段可以看concurrenthashmap(1.7版本及以前)
* 乐观锁，比如1.8的concurrenthashmap就使用synchronized和CAS算法来保证线程安全